<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pannable Chat Map Mockup</title>
    <!-- 1. Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 2. Load 'Inter' font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
            color: #e3e3e3;
            /* Use a dark, subtly patterned background for the viewport */
            background-color: #131314;
            background-image: linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 20px 20px;
            overflow: hidden; /* Prevent body scroll */
        }

        /* --- NEW: History Bar --- */
        #history-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background-color: rgba(30, 30, 33, 0.9);
            border-bottom: 1px solid #4a4a50;
            padding: 8px 16px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
            z-index: 300;
            backdrop-filter: blur(5px);
        }
        .history-link {
            color: #a0c4ff;
            text-decoration: none;
            font-weight: 500;
            font-size: 0.9rem;
            padding: 4px 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .history-link:hover {
            background-color: rgba(160, 196, 255, 0.1);
        }
        .history-link[disabled] {
            color: #e3e3e3;
            font-weight: 600;
            background-color: rgba(160, 196, 255, 0.2);
            cursor: default;
        }
        .history-separator {
            color: #777;
            font-size: 0.9rem;
            user-select: none;
        }
        /* --- END: History Bar --- */


        /* The viewport fills the screen and hides overflow */
        #viewport {
            position: fixed;
            top: 0; /* --- UPDATED: Make space for history bar --- */
            left: 0;
            width: 100vw;
            height: 100vh; /* --- UPDATED: Fill screen --- */
            overflow: hidden;
            cursor: grab;
            padding-top: 45px; /* --- NEW: Space for history bar --- */
        }
        #viewport.is-panning {
            cursor: grabbing;
        }

        /* The canvas is the pannable element inside the viewport */
        #canvas {
            position: relative;
            width: 100%;
            height: 100%;
            /* --- UPDATED: Transform origin top-left for zoom --- */
            transform-origin: 0 0;
            /* transition: transform 0.1s ease-out; */ /* Disabling for smoother zoom/pan */
        }

        /* --- NEW: SVG layer for connectors --- */
        #connector-svg {
            position: absolute;
            /* --- START OF FIX --- */
            /* Give the SVG a huge size and center it on the canvas's (0,0) */
            /* This way, lines can be drawn in all directions without clipping */
            width: 20000px; 
            height: 20000px;
            top: -10000px;
            left: -10000px;
            /* --- END OF FIX --- */
            z-index: 1; /* Behind nodes */
            pointer-events: none; /* Lets clicks pass through */
        }

        /* Base style for all chat nodes */
        .chat-node {
            position: absolute;
            width: 350px;
            background-color: #2a2a2e;
            border: 1px solid #4a4a50;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            overflow: visible; /* --- UPDATED: Allow buttons to show --- */
            /* Add a subtle glow */
            box-shadow: 0 0 15px rgba(130, 170, 255, 0.1);
            z-index: 10; /* --- UPDATED: Ensure nodes are above lines --- */
            transition: width 0.2s ease, height 0.2s ease; /* --- NEW: Animate layout changes (removed top/left) --- */
        }

        /* --- NEW: Base Button Styles --- */
        .node-btn {
            position: absolute;
            width: 24px;
            height: 24px;
            background-color: rgba(0,0,0,0.3);
            color: #ccc;
            border: 1px solid #555;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            line-height: 1;
            cursor: pointer;
            z-index: 20;
            transition: all 0.2s;
        }
        .node-btn:hover {
            background-color: rgba(0,0,0,0.6);
            color: white;
            border-color: #777;
            transform: scale(1.1);
        }

        /* --- NEW: Collapse Button --- */
        .node-collapse-btn {
            top: 8px;
            left: 8px;
            font-family: monospace; /* Ensure + and - look right */
            font-size: 1.2rem;
            padding-bottom: 2px; /* Visual centering */
        }

        /* --- NEW: Root Button --- */
        .node-root-btn {
            top: 8px;
            right: 38px; /* Moved left to make room for remove btn */
            font-size: 0.9rem; /* Smaller icon */
            padding: 0;
        }

        /* --- NEW: Remove Button --- */
        .node-remove-btn {
            top: 8px;
            right: 8px;
            font-size: 1.1rem;
            color: #ff6b6b;
            border-color: #5a2a2a;
            line-height: 0.8;
            padding-bottom: 3px;
        }
        .node-remove-btn:hover {
            background-color: rgba(255, 107, 107, 0.15);
            color: #ff8888;
            border-color: #ff6b6b;
        }

        /* --- NEW: Collapsed Node Styles --- */
        .chat-node.collapsed {
            width: 250px; /* Shrink width */
            height: auto; /* Shrink height */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        .chat-node.collapsed .node-response,
        .chat-node.collapsed .node-prompt p.prompt-text,
        .chat-node.collapsed .node-prompt p.prompt-context,
        .chat-node.collapsed .node-debug-id { /* --- NEW: Hide debug ID --- */
            display: none; /* Hide response and prompt text */
        }
        .chat-node.collapsed .node-prompt {
            border-bottom: none; /* Remove border when collapsed */
        }
        /* --- END: Collapse Styles --- */

        /* User's prompt section within a node */
        .node-prompt {
            padding: 12px 16px;
            background-color: #3a3a40;
            border-bottom: 1px solid #4a4a50;
            /* --- NEW: Make room for buttons --- */
            padding-left: 40px;
            padding-right: 40px;
        }
        .node-prompt p:first-child {
            font-weight: 600;
            color: #c5c5c5;
        }
        .node-prompt p.prompt-text {
            font-style: italic;
            color: #ffffff;
        }

        /* AI's response section within a node */
        .node-response {
            padding: 16px;
        }
        .node-response p:first-child {
            font-weight: 600;
            color: #e3e3e3; /* UPDATED: Changed from blue-ish to white-ish */
            margin-bottom: 8px;
        }

        /* This is the key part: make the response text selectable */
        .node-response-content {
            font-size: 0.9rem;
            line-height: 1.5;
            /* This ensures the user can select the text */
            user-select: text; 
            cursor: text;
        }
        
        .instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
            z-index: 100;
            pointer-events: none;
        }

        /* --- UPDATED: New styles for the highlight confirmation popup --- */
        #highlight-popup {
            position: absolute; /* UPDATED: Was 'fixed', now 'absolute' to move with canvas */
            display: none; /* Hidden by default */
            background-color: #2a2a2e; /* Match node background */
            border: 1px solid #4a4a50; /* Match node border */
            color: white;
            padding: 12px;
            border-radius: 10px;
            font-size: 0.9rem;
            font-weight: 500;
            z-index: 200;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: opacity 0.1s ease-out;
            width: 300px; /* Give it a fixed width */
            /* UPDATED: Was 'display: flex' in thought, but must be 'none' by default */
            flex-direction: column; /* Stack items vertically */
            gap: 10px; /* Add spacing between items */
            transform-origin: top left; /* NEW: For scaling from top-left corner */
        }

        .popup-highlight-context {
            font-size: 0.8rem;
            color: #c5c5c5;
        }
        .popup-highlight-context strong {
            color: #e0e0e0;
        }

        #popup-highlighted-text {
            font-style: italic;
            color: #ffffff;
            /* Add text truncation for long highlights */
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-top: 4px; /* Spacing from "Highlighted:" */
        }

        #popup-prompt-input {
            width: 100%;
            padding: 8px 10px;
            border-radius: 6px;
            background-color: #3a3a40;
            border: 1px solid #4a4a50;
            color: white;
            font-size: 0.9rem;
        }
        #popup-prompt-input::placeholder {
            color: #888;
        }

        #popup-create-branch-btn {
            background-color: #1a73e8; /* A bright blue */
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
            text-align: center;
            border: none; /* Ensure no default button border */
        }
        #popup-create-branch-btn:hover {
            background-color: #2a83f8;
        }
        /* --- END OF POPUP STYLE UPDATES --- */

        /* --- UPDATED: New styles for the highlight confirmation popup --- */
    </style>
</head>
<body>

    <!-- --- NEW: History Bar --- -->
    <div id="history-bar">
        <div id="history-links-container" style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
            <!-- History links will be added here by JS -->
        </div>
        <div style="margin-left: auto; display: flex; gap: 8px; align-items: center;">
             <select id="gemini-model-select" style="background: #2a2a2e; border: 1px solid #4a4a50; color: white; padding: 4px 8px; border-radius: 4px; font-size: 0.8rem;">
                <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
                <option value="gemini-2.0-flash">Gemini 2.0 Flash</option>
                <option value="gemini-1.5-flash-latest">Gemini 1.5 Flash (Latest)</option>
                <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
                <option value="gemini-1.5-pro-latest">Gemini 1.5 Pro (Latest)</option>
                <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
                <option value="gemini-pro">Gemini Pro</option>
             </select>
             <input type="password" id="gemini-api-key" placeholder="Gemini API Key" style="background: #2a2a2e; border: 1px solid #4a4a50; color: white; padding: 4px 8px; border-radius: 4px; font-size: 0.8rem; width: 200px;">
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #131314; z-index: 250; display: flex; flex-direction: column; align-items: center; justify-content: center; padding-top: 50px;">
        <h1 style="font-size: 2rem; font-weight: 700; margin-bottom: 2rem; color: #e3e3e3;">Gemini Chat Map</h1>
        <div style="width: 100%; max-width: 600px; padding: 0 20px;">
            <textarea id="start-prompt-input" placeholder="What do you want to explore?" style="width: 100%; padding: 16px; background: #2a2a2e; border: 1px solid #4a4a50; border-radius: 12px; color: white; font-size: 1.1rem; resize: none; height: 120px; margin-bottom: 16px; font-family: inherit;"></textarea>
            
            <!-- NEW: File Input for Start Screen -->
            <div style="margin-bottom: 16px; display: flex; align-items: center; gap: 10px;">
                <label for="start-file-input" style="cursor: pointer; background: #3a3a40; padding: 6px 12px; border-radius: 6px; font-size: 0.9rem; color: #e3e3e3; border: 1px solid #4a4a50;">
                    ðŸ“Ž Attach File
                </label>
                <input type="file" id="start-file-input" style="display: none;">
                <span id="start-file-name" style="font-size: 0.9rem; color: #aaa;"></span>
            </div>

            <button id="start-btn" style="width: 100%; padding: 12px; background: #1a73e8; color: white; border: none; border-radius: 8px; font-size: 1rem; font-weight: 600; cursor: pointer; transition: background 0.2s;">Start Mapping</button>
        </div>
    </div>

    <!-- This viewport fills the screen and allows panning -->
    <div id="viewport">
        <!-- The canvas holds all the nodes and is the element that moves -->
        <div id="canvas">

            <!-- 
                ================================================
                NEW: SVG Layer for Connectors
                This must come *before* the nodes so it's behind them.
                ================================================
            -->
            <svg id="connector-svg">
                <!-- Lines will be dynamically added here by JavaScript -->
            </svg>

            <!-- 
                ================================================
                ROOT NODE (Response A)
                This is the starting point of the map.
                ================================================
            -->
            <!-- Node A will be created dynamically -->

            <!-- New HTML element for the popup button -->
            <!-- UPDATED: This is now a div container, not just a button -->
            <!-- UPDATED: Moved inside #canvas -->
            <div id="highlight-popup">
                <div class="popup-highlight-context">
                    <strong>Highlighted:</strong>
                    <div id="popup-highlighted-text"></div>
                </div>
                <input type="text" id="popup-prompt-input" placeholder="Ask a follow-up question...">
                
                <!-- NEW: File Input for Popup -->
                <div style="display: flex; align-items: center; gap: 8px;">
                    <label for="popup-file-input" style="cursor: pointer; color: #a0c4ff; font-size: 0.8rem; display: flex; align-items: center; gap: 4px;">
                        <span>ðŸ“Ž</span> Add File
                    </label>
                    <input type="file" id="popup-file-input" style="display: none;">
                    <span id="popup-file-name" style="font-size: 0.8rem; color: #ccc; max-width: 120px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;"></span>
                </div>

                <button id="popup-create-branch-btn">Create Branch</button>
            </div>

        </div>
    </div>

    <div class="instructions">
        Click and drag to pan. Scroll to zoom.
    </div>

    <script>
        // --- Global State ---
        const viewport = document.getElementById('viewport');
        const canvas = document.getElementById('canvas');
        const popup = document.getElementById('highlight-popup');
        const popupHighlightedTextEl = document.getElementById('popup-highlighted-text');
        const popupPromptInputEl = document.getElementById('popup-prompt-input');
        const popupCreateBranchBtn = document.getElementById('popup-create-branch-btn');
        const svgCanvas = document.getElementById('connector-svg');
        const historyBar = document.getElementById('history-bar');
        const historyLinksContainer = document.getElementById('history-links-container');
        const apiKeyInput = document.getElementById('gemini-api-key');
        const modelSelect = document.getElementById('gemini-model-select');
        const startScreen = document.getElementById('start-screen');
        const startPromptInput = document.getElementById('start-prompt-input');
        const startBtn = document.getElementById('start-btn');
        const startFileInput = document.getElementById('start-file-input');
        const startFileName = document.getElementById('start-file-name');
        const popupFileInput = document.getElementById('popup-file-input');
        const popupFileName = document.getElementById('popup-file-name');
        const NS = 'http://www.w3.org/2000/svg'; // SVG Namespace

        // Load API Key & Model
        if(localStorage.getItem('gemini_api_key')) {
            apiKeyInput.value = localStorage.getItem('gemini_api_key');
        }
        if(localStorage.getItem('gemini_model')) {
            modelSelect.value = localStorage.getItem('gemini_model');
        }

        apiKeyInput.addEventListener('input', (e) => {
            localStorage.setItem('gemini_api_key', e.target.value);
        });
        modelSelect.addEventListener('change', (e) => {
            localStorage.setItem('gemini_model', e.target.value);
        });

        let isPanning = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let didDrag = false; 
        let justPanned = false;
        
        let canvasX = 0;
        let canvasY = 0;
        let scale = 1;
        const minScale = 0.2;
        const maxScale = 3;

        let currentParentNode = null;
        let currentSelectedText = "";

        // --- NEW: History State ---
        let viewHistory = []; // Start empty


        // --- Panning & Zooming Logic ---
        function applyTransform() {
            canvas.style.transform = `translate(${canvasX}px, ${canvasY}px) scale(${scale})`;
            requestAnimationFrame(updateAllLines);
        }

        // --- NEW: Reset View Function ---
        function resetPanAndZoom() {
            // Get the current root node (last item in history)
            const currentRootId = viewHistory[viewHistory.length - 1];
            const rootNode = document.getElementById(currentRootId);
            
            if (!rootNode) {
                // Failsafe: reset to 0,0
                canvasX = 0;
                canvasY = 0;
                scale = 1;
            } else {
                // --- NEW: Center view on the focused node ---
                // We want to position the node at a nice spot, e.g., (100, 150) in screen-space
                // We also reset zoom to 1
                scale = 1;
                
                // Target screen position
                const targetScreenX = (currentRootId === 'A') ? 100 : 50; // A bit less offset for sub-nodes
                const targetScreenY = (currentRootId === 'A') ? 150 : 50;
                
                // The node's *actual* position on the canvas
                // --- FIX: Use reliable getNodeTop ---
                const nodeCanvasX = getNodeLeft(rootNode); 
                const nodeCanvasY = getNodeTop(rootNode);

                // Calculate the canvas translation needed
                canvasX = targetScreenX - (nodeCanvasX * scale);
                canvasY = targetScreenY - (nodeCanvasY * scale);
            }
            
            applyTransform();
        }

        viewport.addEventListener('mousedown', (e) => {
            const isTextClick = e.target.closest('.node-response-content');
            const isPopupClick = e.target.closest('#highlight-popup');
            const isBtnClick = e.target.closest('.node-btn'); 

            if (isTextClick || isPopupClick || isBtnClick) {
                return; // Don't pan
            }
            
            e.preventDefault();
            isPanning = true;
            didDrag = false; 
            justPanned = false;
            viewport.classList.add('is-panning');
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        viewport.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            
            didDrag = true;
            justPanned = true; 

            const dx = e.clientX - lastMouseX;
            const dy = e.clientY - lastMouseY;

            canvasX += dx;
            canvasY += dy;

            applyTransform(); 
            
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        viewport.addEventListener('mouseup', () => {
            if (isPanning && !didDrag) {
                popup.style.display = 'none';
                currentParentNode = null;
                currentSelectedText = "";
            } 
            isPanning = false;
            viewport.classList.remove('is-panning');
        });

        viewport.addEventListener('mouseleave', () => {
            isPanning = false;
            viewport.classList.remove('is-panning');
        });

        viewport.addEventListener('wheel', (e) => {
            e.preventDefault();
            const scaleAmount = 1 - e.deltaY * 0.005;
            const newScale = Math.max(minScale, Math.min(maxScale, scale * scaleAmount));
            const rect = viewport.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const mouseXOnCanvas = (mouseX - canvasX) / scale;
            const mouseYOnCanvas = (mouseY - canvasY) / scale;
            canvasX = mouseX - (mouseXOnCanvas * newScale);
            canvasY = mouseY - (mouseYOnCanvas * newScale);
            scale = newScale;
            applyTransform();
        });


        // --- Highlight-to-Branch Logic ---
        document.addEventListener('mouseup', (e) => {
            if (justPanned) {
                justPanned = false; 
                return;
            }
            if (isPanning) return;
            
            const responseContent = e.target.closest('.node-response-content');
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();

            if (selectedText.length > 0 && responseContent) {
                currentParentNode = responseContent.closest('.chat-node');
                currentSelectedText = selectedText;
                popupHighlightedTextEl.textContent = currentSelectedText;

                const range = selection.getRangeAt(0);
                const rect = range.getBoundingClientRect();
                
                // --- FIX: Use viewport rect to account for padding ---
                const viewportRect = viewport.getBoundingClientRect();
                const popupScreenX = rect.left - viewportRect.left + (rect.width / 2) - (popup.offsetWidth / 2);
                const popupScreenY = rect.bottom - viewportRect.top + 10;

                const canvasPopupX = (popupScreenX - canvasX) / scale;
                const canvasPopupY = (popupScreenY - canvasY) / scale;

                popup.style.left = `${canvasPopupX}px`;
                popup.style.top = `${canvasPopupY}px`;
                popup.style.display = 'flex';
                popupPromptInputEl.value = ""; 
                popupPromptInputEl.focus();
            } else {
                if (!e.target.closest('#highlight-popup')) {
                    popup.style.display = 'none';
                    currentParentNode = null;
                    currentSelectedText = "";
                }
            }
        });

        popupCreateBranchBtn.addEventListener('click', async () => {
            const newPromptText = popupPromptInputEl.value.trim();
            if (currentParentNode && currentSelectedText) {
                
                let attachment = null;
                if (popupFileInput.files.length > 0) {
                    try {
                        attachment = await fileToBase64(popupFileInput.files[0]);
                    } catch (e) {
                        console.error("File read error:", e);
                    }
                }

                createBranchNode(currentParentNode, currentSelectedText, newPromptText, attachment);
                window.getSelection().removeAllRanges();
                popup.style.display = 'none';
                currentParentNode = null;
                currentSelectedText = "";
                popupPromptInputEl.value = "";
                popupFileInput.value = ""; // Clear file input
                popupFileName.textContent = "";
            }
        });


        // --- --- --- --- --- --- --- --- --- --- --- ---
        // --- NEW: View, History, and Rooting Logic ---
        // --- --- --- --- --- --- --- --- --- --- --- ---

        // Delegated click listener for all node buttons
        canvas.addEventListener('click', (e) => {
            const btn = e.target.closest('.node-btn');
            if (!btn) return;

            const nodeEl = btn.closest('.chat-node');
            if (!nodeEl) return;

            // Handle Collapse
            if (btn.classList.contains('node-collapse-btn')) {
                console.log(`[ToggleCollapse] User clicked collapse on ${nodeEl.id}`);
                toggleCollapse(nodeEl);
            }
            
            // Handle Root
            if (btn.classList.contains('node-root-btn')) {
                console.log(`[Rooting] User rooted on node: ${nodeEl.id}`);
                // Add to history and re-render
                viewHistory.push(nodeEl.id);
                renderView();
            }

            // Handle Remove
            if (btn.classList.contains('node-remove-btn')) {
                if (confirm('Are you sure you want to remove this node and its descendants?')) {
                    removeNode(nodeEl);
                }
            }
        });

        // History bar click listener
        historyBar.addEventListener('click', (e) => {
            const link = e.target.closest('.history-link');
            if (link && !link.disabled) {
                const nodeId = link.dataset.nodeId;
                console.log(`[History] User clicked history link for: ${nodeId}`);
                
                // Find index and slice history
                const index = viewHistory.indexOf(nodeId);
                if (index > -1) {
                    viewHistory = viewHistory.slice(0, index + 1);
                    renderView(); // Re-render the view
                    
                    // --- START OF FIX ---
                    // Always force a recursive re-layout for the target view.
                    // This ensures all descendants (deeply nested ones too) are
                    // correctly stacked before we see them.
                    const targetNode = document.getElementById(nodeId);
                    if (nodeId === 'A') {
                        console.log("[History] Forcing full tree reflow (Root).");
                        runFullTreeReflow();
                    } else {
                        console.log(`[History] Forcing recursive reflow for focused node ${nodeId}.`);
                        // 1. Recurse down to fix all descendants
                        reflowRecursive(targetNode);
                        // 2. Update lines
                        requestAnimationFrame(updateAllLines);
                    }
                    // --- END OF FIX ---
                }
            }
        });

        /**
         * Main function to update the UI based on the current viewHistory state.
         * This handles showing/hiding nodes, updating the history bar, and resetting pan/zoom.
         * It does NOT do layout, it just manages visibility.
         */
        function renderView() {
            if (viewHistory.length === 0) return; // Handle empty history
            const currentRootId = viewHistory[viewHistory.length - 1];
            const currentRootNode = document.getElementById(currentRootId);
            console.log(`[RenderView] Rendering view for history: ${viewHistory.join(', ')}`);
            
            // 1. Update History Bar
            historyLinksContainer.innerHTML = ''; // Clear
            viewHistory.forEach((nodeId, index) => {
                const node = document.getElementById(nodeId);
                const isLast = index === viewHistory.length - 1;
                
                // Add separator
                if (index > 0) {
                    const separator = document.createElement('span');
                    separator.className = 'history-separator';
                    separator.textContent = '>';
                    historyLinksContainer.appendChild(separator);
                }
                
                // Add link
                const link = document.createElement('button');
                link.className = 'history-link';
                link.textContent = (nodeId === 'A') ? 'Root' : `Node ${nodeId}`;
                link.dataset.nodeId = nodeId;
                if (isLast) {
                    link.disabled = true;
                }
                historyLinksContainer.appendChild(link);
            });
            
            // 2. Show/Hide Nodes
            const allNodes = document.querySelectorAll('.chat-node');
            
            if (currentRootId === 'A') {
                // Main "Root" view: Show all nodes
                allNodes.forEach(node => {
                    node.style.display = 'block';
                });
                
                // ...but respect collapsed state
                document.querySelectorAll('.chat-node.collapsed').forEach(collapsedNode => {
                    const descendants = getSubtreeNodes(collapsedNode);
                    for (let i = 1; i < descendants.length; i++) {
                        descendants[i].style.display = 'none';
                    }
                });

            } else {
                // "Focused/Rooted" view: Hide all, then show only descendants
                allNodes.forEach(node => {
                    node.style.display = 'none';
                });
                
                const visibleNodes = getSubtreeNodes(currentRootNode);
                visibleNodes.forEach(node => {
                    node.style.display = 'block';
                    // ...and respect collapsed state within this view
                    if (node.classList.contains('collapsed')) {
                        const descendants = getSubtreeNodes(node);
                        for (let i = 1; i < descendants.length; i++) {
                            descendants[i].style.display = 'none';
                        }
                    }
                });
            }

            // 3. Reset Pan & Zoom to focus on the new root
            resetPanAndZoom();
            
            // 4. Update lines
            requestAnimationFrame(updateAllLines);
        }

        function toggleCollapse(nodeEl) {
            console.log(`[ToggleCollapse] Toggling node: ${nodeEl.id}`);
            const btn = nodeEl.querySelector('.node-collapse-btn');
            const isCollapsing = !nodeEl.classList.contains('collapsed');

            if (isCollapsing) {
                // --- COLLAPSING ---
                nodeEl.classList.add('collapsed');
                if (btn) btn.textContent = '+';
                
                // Hide ALL descendants
                const descendants = getSubtreeNodes(nodeEl);
                for (let i = 1; i < descendants.length; i++) {
                    descendants[i].style.display = 'none';
                }
            } else {
                // --- EXPANDING ---
                nodeEl.classList.remove('collapsed');
                if (btn) btn.textContent = '-';
                
                // Recursively show descendants that aren't collapsed by their *own* parent
                showVisibleDescendants(nodeEl);
            }

            // --- RE-LAYOUT ---
            // --- START OF FIX: View-aware layout ---
            const currentRootId = viewHistory[viewHistory.length - 1];
            if (currentRootId === 'A') {
                // We are in the main view, run the powerful global layout
                console.log(`[ToggleCollapse] In Root view. Calling global runReflow.`);
                runReflow(nodeEl);
            } else {
                // We are in a focused view, run the simple focused layout
                console.log(`[ToggleCollapse] In Focused view. Calling focused reflow.`);
                reflowFocusedView(document.getElementById(currentRootId));
            }
            // --- END OF FIX ---
        }

        /**
         * Recursively shows children of a parent node.
         * If a child is NOT collapsed, it recurses into that child.
         * Returns an array of all nodes it made visible.
         */
        function showVisibleDescendants(parentNode) {
            let visibleNodes = [];
            const children = document.querySelectorAll(`.chat-node[data-parent-id="${parentNode.id}"]`);
            children.forEach(child => {
                // Show the direct child
                child.style.display = 'block';
                visibleNodes.push(child);
                
                // If this child is NOT collapsed, recurse
                if (!child.classList.contains('collapsed')) {
                    visibleNodes = visibleNodes.concat(showVisibleDescendants(child));
                }
            });
            return visibleNodes;
        }

        // --- --- --- --- --- --- --- --- --- ---
        // --- SVG Line Drawing Logic ---
        // --- --- --- --- --- --- --- --- --- --- --- ---
        function updateAllLines() {
            if (!svgCanvas) return;
            svgCanvas.innerHTML = ''; // Clear all existing lines
            const svgOffsetX = 10000;
            const svgOffsetY = 10000;

            const allNodes = document.querySelectorAll('.chat-node:not(#A)');
            
            allNodes.forEach(node => {
                // --- NEW: Don't draw lines for hidden nodes ---
                if (node.style.display === 'none') return;

                const parentId = node.dataset.parentId;
                if (!parentId) return; 

                const parentNode = document.getElementById(parentId);
                if (!parentNode || parentNode.style.display === 'none') return; // Don't draw from hidden parent

                // --- FIX: Use reliable getNodeTop/Left ---
                const startX = getNodeLeft(parentNode) + parentNode.offsetWidth + svgOffsetX;
                const startY = getNodeTop(parentNode) + (parentNode.offsetHeight / 2) + svgOffsetY;
                const endX = getNodeLeft(node) + svgOffsetX;
                const endY = getNodeTop(node) + (node.offsetHeight / 2) + svgOffsetY;
                const midX = startX + (endX - startX) / 2;
                
                const pathData = `M ${startX} ${startY} L ${midX} ${startY} L ${midX} ${endY} L ${endX} ${endY}`;
                
                // --- FIX: Use correct SVG namespace ---
                const path = document.createElementNS(NS, 'path');
                path.setAttribute('d', pathData);
                path.setAttribute('stroke', '#5a5a60'); // Line color
                path.setAttribute('stroke-width', '2');
                path.setAttribute('fill', 'none');
                path.setAttribute('vector-effect', 'non-scaling-stroke');
                
                svgCanvas.appendChild(path);
            });
        }


        // --- --- --- --- --- --- --- --- --- ---
        // --- NEW: Global Layout Engine ---
        // --- --- --- --- --- --- --- --- --- ---

        // --- START OF FIX: Reliable position getters ---
        /**
         * Safely gets the 'top' position of a node from its style.
         * @param {HTMLElement} node The node to measure.
         * @returns {number} The top position in pixels.
         */
        function getNodeTop(node) {
            if (!node) return 0;
            // First, try to parse the style.top value
            const styleTop = parseFloat(node.style.top);
            // If it's NaN (e.g., not set yet), return the offsetTop as a fallback.
            // This is crucial for the very first placement of node 'A'.
            if (isNaN(styleTop)) {
                return node.offsetTop || 0;
            }
            return styleTop;
        }

        /**
         * Safely gets the 'left' position of a node from its style.
         * @param {HTMLElement} node The node to measure.
         * @returns {number} The left position in pixels.
         */
        function getNodeLeft(node) {
            if (!node) return 0;
            const styleLeft = parseFloat(node.style.left);
            if (isNaN(styleLeft)) {
                return node.offsetLeft || 0;
            }
            return styleLeft;
        }
        // --- END OF FIX ---


        /**
         * Finds the lowest vertical point of a node's entire subtree.
         * --- MODIFIED: Uses getNodeTop and respects .collapsed ---
         */
        function getSubtreeMaxBottom(startNode) {
            // --- FIX: Use reliable getNodeTop ---
            // --- FIX: We MUST use offsetHeight, as it's the only
            // reliable measure of a node's true height (including content).
            // This is why layout MUST run only when nodes are visible.
            let maxBottom = getNodeTop(startNode) + startNode.offsetHeight;
            
            // If the node itself is collapsed, its children don't count towards its bottom.
            if (startNode.classList.contains('collapsed')) {
                return maxBottom;
            }

            const children = document.querySelectorAll(`.chat-node[data-parent-id="${startNode.id}"]`);
            children.forEach(child => {
                maxBottom = Math.max(maxBottom, getSubtreeMaxBottom(child));
            });
            return maxBottom;
        }

        /**
         * Gets a node AND all its descendants, recursively.
         */
        function getSubtreeNodes(startNode) {
            let nodes = [startNode];
            const children = document.querySelectorAll(`.chat-node[data-parent-id="${startNode.id}"]`);
            children.forEach(child => {
                nodes = nodes.concat(getSubtreeNodes(child));
            });
            return nodes;
        }

        // --- NEW: Bottom-Up Recursive Reflow ---
        // This guarantees that when a parent is processed, all its children
        // (and their children) have already been laid out.
        function runFullTreeReflow() {
            const root = document.getElementById('A');
            console.log("[RunFullTreeReflow] Starting full recursive reflow.");
            
            // 1. Bottom-up traversal to layout all sub-branches first
            reflowRecursive(root);
            
            // 2. Finally layout the main branches
            reflowVerticalLayout();
        }

        function reflowRecursive(parentNode) {
             // 1. Recurse to leaves first
             const children = document.querySelectorAll(`.chat-node[data-parent-id="${parentNode.id}"]`);
             children.forEach(child => reflowRecursive(child));
             
             // 2. Reflow this node's children (if any)
             // We skip reflowing children of 'A' here, that's done in reflowVerticalLayout
             if (children.length > 0 && parentNode.id !== 'A') {
                 reflowSubBranchLayout(parentNode);
             }
        }

        /**
         * Re-stacks all sub-nodes (siblings) within a given parent.
         * This is the "absolute" version that fixes the layout bugs.
         */
        function reflowSubBranchLayout(parentNode) {
            console.log(`[Reflow-Sub] Starting sub-reflow for children of ${parentNode.id}`);
            const children = [];
            document.querySelectorAll(`.chat-node[data-parent-id="${parentNode.id}"]`).forEach(node => {
                children.push(node);
            });
            
            // Sort by ID to ensure correct stacking order (A1-1, A1-2, A1-3...)
            children.sort((a, b) => {
                const aId = a.id.split('-').pop();
                const bId = b.id.split('-').pop();
                // We need to handle 'A1' vs 'A2' (string sort 'A2' > 'A1')
                // but also 'A1-1' vs 'A1-2' (number sort 2 > 1)
                // A simple numeric sort on the last part is best.
                return parseInt(aId) - parseInt(bId);
            });
            
            let currentMaxBottom = 0; 
            const parentTop = getNodeTop(parentNode);

            children.forEach((childNode, index) => {
                const oldTop = getNodeTop(childNode);
                let newTop;

                if (index === 0) {
                    newTop = parentTop; // First child ALWAYS aligns with parent
                } else {
                    // Subsequent children stack below the *previous* sibling's max bottom
                    newTop = currentMaxBottom + 20; 
                }
                
                const deltaY = newTop - oldTop;

                if (deltaY !== 0) {
                    // Only move if position changed (prevents infinite loops)
                     const subtreeNodes = getSubtreeNodes(childNode);
                    subtreeNodes.forEach(node => {
                        node.style.top = (getNodeTop(node) + deltaY) + 'px';
                    });
                }
                
                canvas.offsetHeight; // Force reflow
                // Get the *new* max bottom of this child's subtree
                currentMaxBottom = getSubtreeMaxBottom(childNode);
            });
        }

        /**
         * Re-stacks all Tier 1 (main) branches (A1, A2, A3...)
         * This is the "absolute" version.
         */
        function reflowVerticalLayout() {
            const rootNode = document.getElementById('A');
            console.log("[Reflow-Main] Starting main vertical layout reflow...");
            
            const rootBranches = [];
            document.querySelectorAll('.chat-node[data-parent-id="A"]').forEach(node => {
                rootBranches.push(node);
            });
            
            // Sort by ID to ensure correct stacking order (A1, A2, A3...)
            rootBranches.sort((a, b) => {
                const aNum = parseInt(a.id.replace('A', ''));
                const bNum = parseInt(b.id.replace('A', ''));
                return aNum - bNum;
            });
            
            let currentMaxBottom = 0;
            const rootTop = getNodeTop(rootNode);

            rootBranches.forEach((rootBranchNode, index) => {
                const branchId = rootBranchNode.dataset.branchId;
                const allBranchNodes = document.querySelectorAll(`.chat-node[data-branch-id="${branchId}"]`);
                if (allBranchNodes.length === 0) return;

                const oldTop = getNodeTop(rootBranchNode);
                let newTop;

                if (index === 0) {
                    newTop = rootTop; // First branch (A1) ALWAYS aligns with Root 'A'
                } else {
                    newTop = currentMaxBottom + 20; // Stack below previous
                }
                
                const deltaY = newTop - oldTop;

                if (deltaY !== 0) {
                    allBranchNodes.forEach(node => {
                        node.style.top = (getNodeTop(node) + deltaY) + 'px';
                    });
                }
                
                canvas.offsetHeight; // Force reflow
                
                // Get the *new* max bottom of this entire branch's subtree
                currentMaxBottom = getSubtreeMaxBottom(rootBranchNode);
            });

            requestAnimationFrame(updateAllLines);
            console.log("[Reflow-Main] Reflow complete.");
        }

        /**
         * Orchestrator function for all GLOBAL layout changes.
         * Climbs the tree from the changed node, reflowing sub-branches,
         * and then always reflows the main vertical layout.
         */
        function runReflow(changedNode) {
            console.log(`[Reflow-Orchestrator] Starting reflow from node ${changedNode.id}`);
            
            // 1. Climb the tree and reflow all parent sub-branches
            let currentNode = changedNode;
            while (currentNode && currentNode.dataset.parentId) {
                const parent = document.getElementById(currentNode.dataset.parentId);
                if (!parent) break;
                
                // Don't run sub-reflow on 'A' itself.
                if (parent.id === 'A') break; 
                
                reflowSubBranchLayout(parent);
                currentNode = parent;
            }

            // 2. ALWAYS reflow the main vertical layout after.
            // This ensures all main branches (A1, A2...) are
            // correctly stacked.
            reflowVerticalLayout();
        }
        
        // --- START OF FIX: New function for focused layout ---
        /**
         * A simple layout function that ONLY stacks the direct children
         * of the currently focused root node. It does not touch
         * any other nodes on the map.
         */
        function reflowFocusedView(focusedRootNode) {
            console.log(`[Reflow-Focused] Stacking children for focused root: ${focusedRootNode.id}`);
            
            const children = [];
            document.querySelectorAll(`.chat-node[data-parent-id="${focusedRootNode.id}"]`).forEach(node => {
                // --- FIX: Only stack VISIBLE children ---
                if (node.style.display !== 'none') {
                    children.push(node);
                }
            });
            
            // Sort by ID to ensure correct stacking order
            children.sort((a, b) => {
                const aId = parseInt(a.id.split('-').pop());
                const bId = parseInt(b.id.split('-').pop());
                return aId - bId;
            });
            
            let currentMaxBottom = 0;
            // In a focused view, the root node is always at its own top position.
            const parentTop = getNodeTop(focusedRootNode); 

            children.forEach((childNode, index) => {
                const oldTop = getNodeTop(childNode);
                let newTop;

                if (index === 0) {
                    newTop = parentTop; // First child ALWAYS aligns with parent
                } else {
                    newTop = currentMaxBottom + 20; 
                }
                
                const deltaY = newTop - oldTop;

                if (deltaY !== 0) {
                    const subtreeNodes = getSubtreeNodes(childNode);
                    subtreeNodes.forEach(node => {
                        node.style.top = (getNodeTop(node) + deltaY) + 'px';
                    });
                }
                
                // We must use getSubtreeMaxBottom, as this child might have
                // its own visible (but collapsed) children.
                currentMaxBottom = getSubtreeMaxBottom(childNode);
            });
            
            requestAnimationFrame(updateAllLines);
        }
        // --- END OF FIX ---


        // --- --- --- --- --- --- --- --- --- --- --- ---
        // --- Node Creation Logic ---
        // --- --- --- --- --- --- --- --- --- --- --- ---
        
        async function callGeminiAPI(prompt, context, attachment = null) {
            const apiKey = localStorage.getItem('gemini_api_key');
            const model = localStorage.getItem('gemini_model') || 'gemini-2.5-flash';
            
            if (!apiKey) {
                return "Error: No API Key provided. Please enter your Gemini API Key in the top bar.";
            }

            let fullPrompt = `Context: "${context}"\n\nUser Prompt: ${prompt}\n\nPlease provide a concise and helpful response.`;
            
            // Construct parts array
            const parts = [{ text: fullPrompt }];
            
            // Add attachment if present
            if (attachment) {
                parts.push({
                    inline_data: {
                        mime_type: attachment.mimeType,
                        data: attachment.data
                    }
                });
            }

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: parts
                        }]
                    })
                });

                if (!response.ok) {
                    const err = await response.json();
                    return `Error: ${err.error?.message || response.statusText}`;
                }

                const data = await response.json();
                const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
                return text || "Error: No response text found.";

            } catch (e) {
                return `Error: ${e.message}`;
            }
        }

        async function createBranchNode(parentNode, highlightedText, newPromptText, attachment = null) {
            console.log(`[CreateNode] Branching from parent: ${parentNode.id}`);
            const parentTop = getNodeTop(parentNode);
            const parentLeft = getNodeLeft(parentNode);
            const parentWidth = parentNode.offsetWidth;
            const parentId = parentNode.id;
            
            const newNodeX = parentLeft + parentWidth + 100; // 100px gap
            let newNodeY;

            // --- START OF FIX: View-aware Y-positioning ---
            // Get the current view root
            const currentRootId = viewHistory[viewHistory.length - 1];
            
            // This logic is now universal, but the *nodes it measures*
            // are dependent on the view.
            
            // Check if we are creating a child of the *current view root*
            // (This is equivalent to creating A1 from A, or A1-1 from A1-focused)
            if (parentId === currentRootId) {
                console.log(`[CreateNode] Creating child of current view root.`);
                const siblingNodes = document.querySelectorAll(`.chat-node[data-parent-id="${parentId}"][style*="display: block"]`);
                let maxBottom = 0;
                
                if (siblingNodes.length === 0) {
                    console.log("[CreateNode] This is the first child. Aligning with parent.");
                    newNodeY = parentTop;
                } else {
                    console.log("[CreateNode] Finding max bottom of visible siblings...");
                    siblingNodes.forEach(siblingNode => {
                        maxBottom = Math.max(maxBottom, getSubtreeMaxBottom(siblingNode));
                    });
                    newNodeY = maxBottom + 20;
                    console.log(`[CreateNode] Max bottom found at ${maxBottom}. Placing new node at ${newNodeY}px.`);
                }
            } else {
                // This is a sub-branch (e.g. creating A1-1 from A1, while in Root view)
                // This logic is the same as before.
                console.log("[CreateNode] Creating sub-branch.");
                const siblingNodes = document.querySelectorAll(`.chat-node[data-parent-id="${parentId}"]`);
                let maxBottom = 0; 
                if (siblingNodes.length > 0) {
                    console.log("[CreateNode] Finding max bottom of all sibling sub-trees...");
                    siblingNodes.forEach(siblingNode => {
                        // --- FIX: Must use getSubtreeMaxBottom ---
                        let siblingSubtreeBottom = getSubtreeMaxBottom(siblingNode);
                        maxBottom = Math.max(maxBottom, siblingSubtreeBottom);
                    });
                }
                if (maxBottom === 0) {
                    console.log(`[CreateNode] This is the first sub-node (${parentId}-1). Aligning with parent.`);
                    newNodeY = parentTop;
                } else {
                    console.log(`[CreateNode] Placing subsequent sub-node below sibling. Max bottom: ${maxBottom}`);
                    newNodeY = maxBottom + 20; 
                }
            }
            // --- END OF FIX ---
            
            let childCounter = parseInt(parentNode.dataset.childCounter || 0) + 1;
            parentNode.dataset.childCounter = childCounter;
            let newNodeId = (parentId === 'A') ? 'A' + childCounter : parentId + '-' + childCounter;
            const parentBranchId = parentNode.dataset.branchId;
            let newBranchId = (parentId === 'A') ? newNodeId : parentBranchId; 
            console.log(`[CreateNode] New Node ID: ${newNodeId}, Branch ID: ${newBranchId}`);
            
            let promptTitle, promptContent;
            
            let attachmentHTML = "";
            if (attachment) {
                 if (attachment.mimeType.startsWith('image/')) {
                     attachmentHTML = `<img src="data:${attachment.mimeType};base64,${attachment.data}" style="max-width: 100%; max-height: 150px; border-radius: 8px; margin-top: 8px; display: block;">`;
                 } else {
                     attachmentHTML = `<div style="margin-top: 8px; font-size: 0.8rem; color: #aaa;">ðŸ“Ž Attached File (${attachment.mimeType})</div>`;
                 }
            }

            if (newPromptText && newPromptText.length > 0) {
                promptTitle = "You (follow-up)";
                promptContent = `
                    <p class="prompt-text">${newPromptText}</p>
                    ${attachmentHTML}
                    <p class="prompt-context" style="font-size: 0.8rem; color: #ccc; margin-top: 8px; border-left: 2px solid #555; padding-left: 8px; opacity: 0.8; font-style: italic;">
                        Context: "${highlightedText}"
                    </p>
                `;
            } else {
                promptTitle = "You (highlighted)";
                promptContent = `<p class="prompt-text">${highlightedText}</p>${attachmentHTML}`;
            }

            const newNode = document.createElement('div');
            newNode.id = newNodeId;
            newNode.className = 'chat-node';
            newNode.style.top = `${newNodeY}px`;
            newNode.style.left = `${newNodeX}px`;
            newNode.dataset.branchId = newBranchId;
            newNode.dataset.childCounter = "0";
            newNode.dataset.parentId = parentId;

            newNode.innerHTML = `
                <!-- NEW: Collapse Button -->
                <button class="node-btn node-collapse-btn" title="Collapse/Expand Branch">-</button>
                <!-- NEW: Root Button -->
                <button class="node-btn node-root-btn" title="Focus on this node" data-node-id="${newNodeId}">â—‰</button>
                <!-- NEW: Remove Button -->
                <button class="node-btn node-remove-btn" title="Remove Node">Ã—</button>

                <div class="node-prompt">
                    <p>${promptTitle}</p>
                    ${promptContent}
                </div>
                <div class="node-response">
                    <p>Gemini</p>
                    <div class="node-response-content" id="response-${newNodeId}">
                        <p><span style="color: #888;">Thinking...</span></p>
                    </div>
                </div>
            `;
            
            canvas.appendChild(newNode);
            
            // --- START OF FIX: View-aware layout ---
            if (currentRootId === 'A') {
                // We are in the main view, run the powerful global layout
                console.log(`[CreateNode] In Root view. Calling global runReflow.`);
                runReflow(newNode);
            } else {
                // We are in a focused view, run the simple focused layout
                console.log(`[CreateNode] In Focused view. Calling focused reflow.`);
                reflowFocusedView(document.getElementById(currentRootId));
            }
            // --- END OF FIX ---

            // --- API Call ---
            const apiPrompt = newPromptText || "Elaborate on this.";
            const responseText = await callGeminiAPI(apiPrompt, highlightedText, attachment);
            
            // Simple formatting
            const formattedText = responseText
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\n/g, '<br>');

            const responseContainer = document.getElementById(`response-${newNodeId}`);
            if(responseContainer) {
                responseContainer.innerHTML = `<p>${formattedText}</p>`;
                
                // Re-run layout because height changed
                if (currentRootId === 'A') {
                    runReflow(newNode);
                } else {
                    reflowFocusedView(document.getElementById(currentRootId));
                }
            }
        } 


        // --- --- --- --- --- --- --- --- --- --- --- ---
        // --- Initial Load ---
        // --- --- --- --- --- --- --- --- --- --- --- ---
        
        document.addEventListener('DOMContentLoaded', () => {
            // Initial render on load
            renderView();
        });

        function removeNode(nodeEl) {
            console.log(`[RemoveNode] Removing node: ${nodeEl.id}`);
            const parentId = nodeEl.dataset.parentId;
            const parentNode = document.getElementById(parentId);
            
            // 1. Get all descendants (including self)
            const descendants = getSubtreeNodes(nodeEl);
            
            // 2. Remove them from DOM
            descendants.forEach(node => node.remove());
            
            // 3. Reflow parent to close gaps
            if (parentNode) {
                const currentRootId = viewHistory[viewHistory.length - 1];
                if (currentRootId === 'A') {
                    // In global view, reflow from the parent
                    runReflow(parentNode);
                } else {
                    // In focused view, reflow the current root
                    const rootNode = document.getElementById(currentRootId);
                    if (rootNode) reflowFocusedView(rootNode);
                }
            } else {
                // If we removed the root (A) or a top-level node with no parent
                if (nodeEl.id === 'A') {
                    // Just clear lines, maybe show a "Reset" button later
                    requestAnimationFrame(updateAllLines);
                }
            }
            
            // 4. Update lines
            requestAnimationFrame(updateAllLines);
        }

        // --- Start Screen Logic ---
        startBtn.addEventListener('click', async () => {
            const prompt = startPromptInput.value.trim();
            if (!prompt) return;
            
            startBtn.disabled = true;
            startBtn.textContent = "Generating...";
            
            let attachment = null;
            if (startFileInput.files.length > 0) {
                try {
                    attachment = await fileToBase64(startFileInput.files[0]);
                } catch (e) {
                    console.error("File read error:", e);
                }
            }

            await createRootNode(prompt, attachment);
            
            startScreen.style.display = 'none';
        });

        async function createRootNode(promptText, attachment = null) {
             const newNodeId = 'A';
             
             // Create Node HTML (similar to createBranchNode but for root)
             const newNode = document.createElement('div');
             newNode.id = newNodeId;
             newNode.className = 'chat-node';
             newNode.style.top = '150px';
             newNode.style.left = '100px';
             newNode.dataset.branchId = 'A';
             newNode.dataset.childCounter = "0";
             newNode.dataset.parentId = ""; // Root has no parent

             let attachmentHTML = "";
             if (attachment) {
                 if (attachment.mimeType.startsWith('image/')) {
                     attachmentHTML = `<img src="data:${attachment.mimeType};base64,${attachment.data}" style="max-width: 100%; max-height: 150px; border-radius: 8px; margin-top: 8px; display: block;">`;
                 } else {
                     attachmentHTML = `<div style="margin-top: 8px; font-size: 0.8rem; color: #aaa;">ðŸ“Ž Attached File (${attachment.mimeType})</div>`;
                 }
             }

             newNode.innerHTML = `
                <!-- NEW: Collapse Button -->
                <button class="node-btn node-collapse-btn" title="Collapse/Expand Branch">-</button>
                <!-- NEW: Root Button -->
                <button class="node-btn node-root-btn" title="Focus on this node" data-node-id="${newNodeId}">â—‰</button>
                <!-- NEW: Remove Button -->
                <button class="node-btn node-remove-btn" title="Remove Node">Ã—</button>

                <div class="node-prompt">
                    <p>You</p>
                    <p class="prompt-text">${promptText}</p>
                    ${attachmentHTML}
                </div>
                <div class="node-response">
                    <p>Gemini</p>
                    <div class="node-response-content" id="response-${newNodeId}">
                        <p><span style="color: #888;">Thinking...</span></p>
                    </div>
                </div>
            `;
            
            canvas.appendChild(newNode);
            
            // Update History
            viewHistory = ['A'];
            renderView();

            // API Call
            const responseText = await callGeminiAPI(promptText, "Start of conversation", attachment);
            
            const formattedText = responseText
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\n/g, '<br>');

            const responseContainer = document.getElementById(`response-${newNodeId}`);
            if(responseContainer) {
                responseContainer.innerHTML = `<p>${formattedText}</p>`;
                // Force reflow/layout update if needed
                runReflow(newNode);
            }
        }

        // --- File Input Listeners ---
        startFileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                startFileName.textContent = e.target.files[0].name;
            } else {
                startFileName.textContent = "";
            }
        });

        popupFileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                popupFileName.textContent = e.target.files[0].name;
            } else {
                popupFileName.textContent = "";
            }
        });

        // --- Helper: File to Base64 ---
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => {
                    // Remove the "data:*/*;base64," prefix
                    const base64String = reader.result.split(',')[1];
                    resolve({
                        mimeType: file.type,
                        data: base64String
                    });
                };
                reader.onerror = error => reject(error);
            });
        }
    </script>

</body>
</html>